		Инструменты С++ для обработки текстовой информации

Что такое текстовая информация:
1) символьные константы,
2) символьные переменные (типа char),
3) строки – константы,
4) строковые переменные (массивы символов).

Символьные константы и символьные переменные
Это данные типа char – 1-байтовые данные целого типа (2 байта).
Объявление символьной переменной:
char
unsigned char

Символьная константа - лексема, которая состоит из изображения символа в кавычках '': '*'  '?'  'f'  'Я'  '~'  '#'  '1' и т.д.

Внутреннее представление символов – целочисленный код символа, согласно кодовой таблице имеет значения от 1 до 127, первые 32 - управляющие.
В MS DOS для кодирования используется кодовая таблица ASCII, в Windows - Win1251.

Управляющие символы (ESC - последовательности) требуют двух символов для представления, первый '\':
'\'            -   '\\'
новая строка   -   '\n'
табуляция      -   '\t'
апостроф       -   ''''  '\''

Преимущество представления символов - возможность обращения к ним как к числовым величинам.
1. Можно использовать операции отношения, чтобы сравнивать символы друг с другом, при этом используется порядок следования кодов.
char c1=getchar();
char c2=getchar();
...
char C;
C == '&';		// присваивание константы
Примеры операций над символами
if (c1==c2) 
if (c1<c2)		// типа в лексикографическом порядке
if (c1>='0' && c1<='9')	// является цифрой
if (c2>='а' && c2<='я') || (c2>='А' && c2<='Я' )
if (c2=='.' || c2==',' || c2=='!')	// является знаком препинания

2. Арифметические операции (+, -, ++, --) выполняются над значениями кодов.

3. Можно использовать символьные переменные для управления при организации циклов обработки 
for (char c = 'a'; c<='z'; c++)
{
	// например, сравнение с с.
}

Коды символов
Чтобы узнать коды символов (например, для внешнего управления программой, нужно знать коды клавиш Enter, Esc, F1 и так далее) используется функция bioskey() библиотеки <bios.h>.
Эта функция ждет ввода с клавиатуры значения символа, и имеет три способа обращения в зависимости от параметра:
   1 - ожидает события,
   0 - читает символ,
   2 - читает символ с определением регистра.
Пример Foundkey.
Пример Code.


Строковые константы и строковые переменные
Строковая константа - последовательность символов, заключенная в " ", кроме символов  \ ,  "  и символа новой строки \n.
Управляющие символы, входя в строку, вызывают управляющее воздействие.
Примеры:
    "Строка символов."
    "cлэш запишем как \\ , новую строку как \n"
    " ""апостроф"" повторяем дважды"
Для записи имени файла используется прием:
"d:\\Bc31\\Proba\\File.txt"

Пример Str1

Внутри длинных строк комбинация '\n' означает переход на новую строку.
     Механизм представления строки в памяти 
Строка символов рассматривается как массив символов (типа char[] или char *). Каждый символ хранится в отдельном байте, включая специальные символы.
В конце строки должен быть нулевой байт '\0', как признак конца строки
(термин С-строки).
Добавляется автоматически: 
а) при инициализации строки, 
б) при вводе строки.
Число символов в строке =длина строки+1 (для нулевого символа).
При формировании строки вручную необходимо добавлять этот символ.
Так, длина константы
'W' = 1 байт
длина строки
"W" = 2 байта.
Фактически имя строки - это указатель на ее нулевой байт.

Объявление и инициализация строковых переменных 
Возможно два способа выделения памяти для строк.
1. Как статический массив. Считается, что это плохой стиль, так как длина строки может изменяться ограниченно. На самом деле при обработке строк ограничение на длину существует.
   char  Str[80];          // Длина 79 символов.

2. Как динамический массив. При этом создается динамическая строка данных, для которой также необходимо выделения памяти в указанном количестве.
   char *Str2;
   Str2 = new char[80];    // Выделение динамической памяти - те же 79 символов

Инициализация строковых переменных
Вызывает выделение памяти под запись значения константы
Примеры
char * Str1  = "строка 1  ";      // выделение памяти автоматом 11 байт
char Str2[9] = "строка 2";        // кол-во символов = 9
char Str3[]  = "строка 3";        // специальный инициализатор +1
char Err[4]  = "ошибка";          // !! синтаксическая
char Err[10] = "не ошибка";       // остальные заполнены нулями

Операции над строками
Никаких операций, потому что символьная строка в выражении - это адрес массива символов. Может быть использована везде, где можно использовать указатель.
Не в левой части присваивания!
Присваивание для строк разрешено только при инициализации!
Пример
char str1[] = "Вася + Наташа";      // Определяется длина








		Ввод-вывод символов и текстовых строк
Для символов, строк используются специальные функции.
1. Форматированный ввод-вывод – те же функции библиотеки <stdio.h> printf и scanf, использующие Форматы:
Для символов       %c
Для строк          %s
Особенность - при вводе строка вводится до пробела.
Особенность - ввод-вывод буферизованный, то есть данные не попадают в ОП напрямую, а накапливаются в буфере (фрагмент ОП).
Буфер проталкивается:
    а) при заполнении,
    б) при использовании специальных функций - (fflush).
2. Ввод-вывод символов
Используются функции 
getchar();          //  getch()  getche()
Читает из потока по одному символу за обращение. Чтение начинается при нажатии клавиши Enter.
putchar(символ);    //
Выводит символ в поток.
3. Ввод-вывод строк
Используются функции 
gets (Строка);     // Читает из потока последовательность символов до Enter.
puts (Строка);     // Выводит строку в поток.
Прототипы этих функций описаны так:
char * gets (char *Str);
int puts (const char *Str);

Пример Str2.

       Строки и указатели
Особенности строк связаны с представлением их в памяти как массивов 1-байтовых переменных.
Соотношение строк и указателей взаимно однозначное - имя строки, это адрес ее нулевого байта.
Статическая строка объявляется
char Str1[80];
Указатель, с которым можно связать строку, объявляется
char *pts;	// это 4 байтовая переменная, с которой можно связать строку.
Динамическая строка объявляется как указатель, которому выделена память:
chat *Str2;
Str2 = new char [80];	// те же 80 символов.

Прямая адресация элементов строк:
а) использование цикла for
for (int i=0; i<strlen(Str); i++)     // Функция strlen(Строка) <string.h>
{
	// Обращение к Str[i];
}
б) использование do или while
int i=0;
while (Str[i]!='\0')    // общепринятый способ проверки достижения конца строки
{
	// Обращение к Str[i]
	i++;
}

Пример – копирование одной строки в другую
int i=0;
do
{
   Str2[i]=Str1[i];
}while (Str1[i++]!=’\0’);
puts(Str2);
Нулевой байт должен быть перенесен в строку Str1.


Косвенная адресация элементов строк
Управляет циклом просмотра указатель типа char*, адресующий один символ.
char Str[80];
char * pS;            // Указатель *char - на один символ
pS = Str;             // На Str[0]   pS++ - смещение на 1 байт
while ( *pS!='\0')    // Не найден нулевой символ
{
	// Обращение к элементу = *pS;
	pS++;
}
Пример – копирование одной строки в другую
char *pts1;
char *pts2;
pts1=Str1;
pts2=Str2;		// Запомнили
do
{
   *pts2++=*pts1;
}while (*pts1++!=’\0’);
Развернуть, как просто.

В стиле С++
while ((*pts2++=*pts1)=’\0’);

Пример Str3.
Пример Copy.

Ошибки при работе со строками
Все ошибки связаны с механизмами выделения памяти для строк.
   Если при объявлении указателя текстовая строка проинициализирована, то выделена память, равная длине этой строки. Нельзя пытаться записать в эту строку больше символов, чем выделено.
   Если при объявлении указателя текстовая строка не проинициализирована, то память под запись строки вообще не выделена, и этот указатель можно использовать только как рабочую переменную для косвенной адресации при работе с какой-либо строкой.

Двумерные текстовые массивы
Двумерные массивы, это массивы строк.
Объявление
char text [7][20];
Инициализация:
сhar	* Day[ ] = {"Понедельник", "Вторник", "Среда", "Четверг", "Пятница", "Суббота", "Воскресенье"};
Управление
Если len – число строк, то
for (i == 0; i < len; i++)
{
	// Управление в I той строке
	puts (Day[i]);
}



Функции и строки

Два случая.
1. Строка является параметром функции.

void Имя_функции (char * Имя_строки)

2. Функция возвращает строку. 

char * Имя_функции ()
{
   .. 
   return Указатель_на_строку;	// Типа char *
} 


1 случай. Передача строки в функцию выполняется так же, как и массивов.

char Имя_строки[]
char * Имя_строки

Длина строки не передается, так как строка имеет признак конца '\0', который позволяет управлять циклами перебора символов строки, не выходя за ее пределы.

  int len = strlen(Строка);

Cтрока фактический параметр в вызывающей программе, 
может быть 
а) динамическим или 
б) статическим массивом.
   Через параметр в функцию передается адрес начала символьного массива. Функция и вызывающая программа имеют одинаковые права на изменение содержимого строки.
Замечание! 
char Str[100] ;  // Запрещает менять ее содержимое. 
char *Str = new char[100];  // Динамическая строка.

Пример функции преобразования строки
Compress1, Compress2

2 случай.

   Функция должна сформировать новую строку и вернуть ее.
1) Новую строку можно вернуть через параметры
2) Через имя функции. 
В втором случае это должна быть функция, возвращающая указатель на строку.
Прототип должен иметь вид

char * S (char * str[])
Новая     Старая строка

Пример - функция дублирует символы строки.

char * S_double (char * str[])




{
	// формирование новой строки – динамические массивы
	char * new_S = new char [2* strlen(str)];
     //   char new_S [100];
	//
	new_S[i]  = str[j];
	new_S[i+1]= str[j];
	i+=2;
	j++;
	return new_S;
}

Обращение
char Str[20];
   gets(Str);
char *S;
   S= S_double(Str); 
   puts(S);

Пример функции, возвращающей новую строку. 
Found_word –найдет самое длинное слово строки.





   Библиотеки работы с символами и со строками текста содержат многие полезные функции обработки текстовых данных.
   Замечание. Некоторые библиотеки устарели с смысле VS.
              Библиотеки классов. 
   <string.h>
   <string>             

Библиотека <ctype.h>
содержит функции и макросы проверки и преобразования символов.

int isalpha (int c) 		Возвращает отличное от 0 значение, если с — латинская буква.
char Symbol;
Symbol=getch();
... 
  if (isalpha(Symbol) !=0)

int isascii (int c)		Возвращает отличное от 0 значение, если с — символ кода ASCII (от 0 до 127).

int iscntrl (int c)		Возвращает отличное от 0 значение, если с — управляющий символ с кодами 0х00–0х01F.
int isdigit (int c)		Возвращает отличное от 0 значение, если с — символ цифры от 0 до 9.
int isspace (int c)		Возвращает отличное от 0 значение, если с — обобщенный пробельный символ.
int toascii (int c)		Преобразует целое число в символ кода ASCII, обнуляя все биты, кроме младших, результат от 0 до 127.
int tolower (int v)	Преобразует код буквы латинского алфавита к нижнему регистру, прочие коды не изменяются.
int toupper (int c)	Преобразует код буквы латинского алфавита к вержнему регистру, прочие коды не изменяются.


Библиотека <stdlib.h> 
содержит полезные функции преобразования строк. 

double atof (const char *Str)		Преобразует строку                                 Str в вещественное число.
int atoi (const char *Str)		Преобразует строку                                 Str в целое число.
long atol (const char *Str)		Преобразует строку                                 Str в длинное целое число.
int n = atoi("1233"); 	// n=1233;

char * itoa (int Val, char *Str, int Base)	Преобразует целое число Val в строку Str. Base — основание системы счисления.

char *ecvt(double Val, int ndig, int *dec, int *sign) 	Преобразует вещественное число Val в строку.


Библиотека <string.h> 
содержит полезные функции преобразования строк. 
Функции преобразования строк.

char *strcat (char *Str1, const char *Str2)	Присоединяет (приписывает) строку Str2 к строке Str1 (конкатенация строк).

char *strchr (const char *Str, int C)		Ищет в строке Str первое вхождение символа С. Возвращает указатель на первое вхождение символа, или NULL, если его нет.

int strcmp (const char *Str1, const char *Str2)	
Сравнивает строки Str2 и Str2. Результат отрицателен, если Str1<Str2, равен 0, если Str1==Str2, и положителен, если Str1>Str2.

char *strcpy (char *Str1, char *Str2)		Копирует строку Str2 в строку Str1. Возвращает указатель на копию строки.

unsigned strlen (const char *Str)			Возвращает целочисленную длину строки Str1, включая '\0'.

char *strlwr (char *Str)						Преобразует буквы латинского алфавита из верхнего регистра к нижнему.

char *strupr (char *Str)						Преобразует буквы латинского алфавита из нижнего регистра к верхнему.

char *strncat (char *Str1, const char *Str2, int Cou)	Приписывает Cou символов строки Str2 к строке Str1. Первый символ пишется на место нуль-символа. 

int strncmp (const char *Str1, const char *Str2, int Cou)		Сравнивает части строк Str1 и Str2 в количестве Cou. Результат отрицателен, если Str1<Str2, равен 0, если Str1==Str2, и положителен, если Str1>Str2.

char * strncpy (char *Str1, const char *Str2, int Cou)	Копирует Cou символов строки Str2 в строку Str1.

char *strpbrk (const char *Str1, const char *Str2)		Ищет в строке Str1 первое появление любого из символов, входящих в строку Str2. Возвращает указатель на символ, а если его нет, то NULL.

char *strrchr (const char *Str, int C)		Отыскивает в строке Str последнее вхождение символа С. Возвращает указатель на символ, а если его нет, то NULL.

char *strset (char *Str, int C)			Заполняет строку Str заданным символом С.

char *strstr (const char *Str1, const char *Str2)	Ищет в строке Str1 подстроку Str2. Возвращает указатель на тот элемент в строке Str1, с которого начинается подстрока Str2, или NULL, если поиск неудачен.


Пример.

k = strlen(l);
char    l1[80], l2[80];

scanf("%s", l1);
strcpy(l2, l1);
strcat(l2, l1);



??

??

??

??




6


