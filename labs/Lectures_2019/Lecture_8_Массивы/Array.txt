          П Р О И З В О Д Н Ы Е   Т И П Ы   Д А Н Н Ы Х

Примерная классификация типов данных С++:
   1) базовые (предопределенные, стандартные, встроенные, примитивные),
   2) конструируемые - строятся на основе других типов, не обязательно базовых.


   Конструируемый тип должен быть описан пользователем перед употреблением.


Примерная классификация производных типов
   1. Функции (частный случай типа, так как возвращает значение, обладающее типом).

   2. Массивы.

   3. Указатели (инструмент для работы с адресами ОП).

   4. Строки (частный случай массива + библиотека обработки строк).

   5. Структуры (для объединения в одно целое разнородных данных).

   6. Объединения.

   7. Классы - "Высокоуровневые методы информатики и программирования".

			МАССИВЫ
Определение. Массив - упорядоченное множество однородных величин, объединенных общим именем.
Важно!!  Все элементы массива имеют один и тот же тип.

Тип элементов массива - почти любой, не обязательно базовый тип 
(массив массивов, массив структур, и так далее...).
Например:
   1. Массив координат точек на плоскости (координаты x, y).
   2. Массив сведений о студенте (Имя, Фамилия, Рост, Вес, Цвет_глаз и т.д.).


Обязательные атрибуты массива (связаны с механизмами выделения памяти):

   a) размерность (стандарт С++ - 1-мерные массивы - векторы данных),
   b) число элементов (знать, сколько данных),
   c) тип элементов (знать, сколько выделить памяти).


Объявление массива = описание массива:
Назначение:
  1) конструирование нового типа,
  2) инициализация (необязательна) - присваивание значений элементам массива.


Синтаксис описания массива

Тип  Имя_массива [Кол_во_элементов];  // Возможно, список инициализации


Здесь 
Кол_во_элементов – константная величина (константа или define константа).

Причина: для статических массивов память выделяется при компиляции программы в сегменте данных. 

Тип - практически любой тип данных.

Примеры:
#define N 100
. . .
int  mas[4];		// 4 int значения, все имеют имя mas

int  matr[2][3];        // Массив массивов

float w[N];		// N=100

char  c[N][80];         // Текст - N строк, по 80 символов)

Внимание! Элементы массива нумеруются с 0, таким образом, для
  int mas[4];
  имеются элементы   mas[0], mas[1], mas[2], mas[3]

В С++ нет контроля выход а за границу массива.


Размещение массивов в памяти
   Всегда подряд в соответствии с ростом номера элемента внутри массива (индекса). Имя массива сопоставлено всей совокупности данных.


Размещение элементов массива в ОП
Пусть объявлен и инициализирован массив
int mas[4] = {10,20,30,40};
int i;	// Для нумерации элементов массива

      Имя mas
      -------+------+------+------+------+------+------+------+------¬
      ¦     1¦0     ¦     2¦0     ¦     3¦0     ¦     4¦0     ¦      ¦
      +------+------+------+------+------+------+------+------+-------
      ¦             ¦             ¦             ¦             ¦
         4 байтa       4 байта        4 байта       4 байта..
	  mas[0]        mas[1]         mas[2]         mas[3]
	  i = 0         i = 1          i = 2          i = 3


Операция sizeof
   Позволяет определить общий размер памяти, занимаемой 
     а) данным любого типа (в том числе массивом),
     б) типом
Примеры:
     int Count = sizeof (mas) - в байтах
     sizeof (x)           - x - имя переменной
     sizeof (long int)    - long int - имя типа


Операции с массивами
   Никаких операций с массивами не разрешено, кроме 

операции обращения к элементам массива [], синтаксис которой: 

Операнд_1 [Операнд_2] 

Фактически, это составное имя:
Имя_массива [Индекс] 
  
   Семантика операции [] - позволяет выделить один элемент с указанным номером.
   Индекс - выражение целого типа, определяющее номер элемента внутри массива (счет с 0).


Инициализация элементов при описании
Инициализация = присвоить значение ПРИ ОБЪЯВЛЕНИИ

int a=99;


   Для инициализации массива можно задать список инициализирующих значений в {}.

Пример:
int month [12] = {31,28,31,30,31,30,31,31,30,31,30,31};     

Удобно использовать инициализацию:  
   а) если значения не меняются,
   б) при отладке.

Эквивалент - присваивание вида:
month[0]  = 31;       // Январь  
		       .. и т.д.
month[11] = 31;      // Декабрь


Возможны варианты:

  1) int month []   = {31,28,30,31,30,31,30,31,30,31};    //Кол-во = 12
  
  2) int month [12] = {31,28,31,30};    // Выделено 12, остальные = 0
  
  3) int month [2]  = {31,28,31,30};    // Ошибка !


   Программно можно определить число элементов по длине списка так:
   
   int a [] = {1,2,3,4,5,6,7,8,9,10,11,12};	// Скольки их?

   int len_a;

   len_a = sizeof(a)/sizeof(int);

 
Управление в алгоритмах работы с массивами
   Как правило, действия применяются ко всем элементам массива по очереди.

   Управление выполняется в циклах, где управляющей переменной является индекс элемента массива. 
   for

Пусть 
#define N 10
...
int mas[N];

Индекс = [0, N-1], приращение = 1.

// Синтаксис управления:
for (int i=0; i<N; i++)            // Здесь N - число элементов  i < N !
	{
	   // обращение к mas[i]
	}
for (int i=N-1; i>=0; i--)         // Здесь N - число элементов  i < N !
	{
	   // обращение к mas[i]
	}


   Массивы условно переменной длины
Один из недостатков массивов - длина статического массива жестко задана в программе (константа). 

Выходы.
  1) #define определенные константы,
  2) массив условно переменной длины,
  3) динамические массивы.
Кроме того, использование функций обработки массивов, которые решают задачу "В общем виде" - получая абстрактный массив произвольной длины.


//===========================
1. #define константы.
Механизм #define константы - изменение текста программы перед ее компиляцией.
Длина массива записывается в директиве #define, например:
#define	N	20
Имя N - именованная константа, в тексте программы для управления алгоритмами обработки массива используется имя N.
Числовое значение константы 20 записывается в тексте один раз. Перед очередным запуском программы может быть изменено один раз, остальные изменения выполнит препроцессор. После этого программа нуждается в повторной компиляции и сборке.
Пример.
2. Использование массивов условно переменной длины.
Длина массива может быть оценена заранее. Это, возможно, наибольшее значение, следует выбрать для описания массива.
Чтобы знать реальную длину массива, вводится специальная переменная, которая принимает значение при выполнении программы, а затем использует его для управления алгоритмами обработки массива.
Пример.
Оба приема можно совместить.
Пример.

Функции работы с массивами
Функции работы с массивами:
1) Решают задачу обработки массива "в общем виде".
2) Получают массив через параметры "в общем виде".
2) Могут обрабатывать массив любой длины.

Случайное присваивание значений       
   Используется функция random, прототип которой: 
int random(int Число)
   Диапазон генерируемых значений ( от 0 до "Число-1")
   Для запуска генератора случайных чисел используется функция 
randomize() - вызывается один раз при старте программы (от системного времени) - прототип в stdlib.h  time.h

Алгоритмы работы с  одномерными массивами 
   1. Вывод элементов массива.
   2. Ввод элементов массива.
   3. Прямой поиск - поиск первого, последнего, любого, поиск с флагом.
   4. Суммирование и его клоны.
   5. Алгоритмы с изменением длины массива - вставка и удаление.
   6. Сортировки. 
